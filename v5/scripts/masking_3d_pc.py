import open3d as o3d
import torch
import os, sys
import numpy as np
import matplotlib.pyplot as plt
import trimesh

FileDirPath = os.path.abspath(__file__)
FileDirPath = os.path.dirname(FileDirPath)
FileDirPath = os.path.dirname(FileDirPath)
sys.path.append(FileDirPath)
sys.path.append(os.path.join(FileDirPath, 'loaders'))
sys.path.append(os.path.join(FileDirPath, 'losses'))
sys.path.append(os.path.join(FileDirPath, 'models'))
from odf_models import ODFSingleV3, ODFSingleV3Constant, ODFSingleV3SH, ODFSingleV3ConstantSH, ODFV5, IntersectionMask3D, IntersectionMask3DV2, ODFMaskOccNet

import v5_utils

icosahedron_verts = [
[0., -0.525731, 0.850651],
[0.850651, 0., 0.525731],
[0.850651, 0., -0.525731],
[-0.850651, 0., -0.525731],
[-0.850651, 0., 0.525731],
[-0.525731, 0.850651, 0.],
[0.525731, 0.850651, 0.],
[0.525731, -0.850651, 0.],
[-0.525731, -0.850651, 0.],
[0., -0.525731, -0.850651],
[0., 0.525731, -0.850651],
[0., 0.525731, 0.850651]
]

icosahedron_faces = [
[2, 3, 7],
[2, 8, 3],
[4, 5, 6],
[5, 4, 9],
[7, 6, 12],
[6, 7, 11],
[10, 11, 3],
[11, 10, 4],
[8, 9, 10],
[9, 8, 1],
[12, 1, 2],
[1, 12, 5],
[7, 3, 11],
[2, 7, 12],
[4, 6, 11],
[6, 5, 12],
[3, 8, 10],
[8, 2, 1],
[4, 10, 9],
[5, 9, 1]
]

def sphere_subdivision(verts, faces, radius=1.0):
    '''
    Verts - a list of numpy arrays defining the current vertices
    Faces - a list of lists defining the connections between the vertices
    '''
    output_verts = [v for v in verts]
    output_faces = []
    # maps an edge (two vertex indices) to the new intermediate vertex index
    new_vertex_indices = {}

    for f in faces:

        # Calculate the three new vertices, use existing vertices if they have already been added
        if (f[0], f[1]) in new_vertex_indices:
            v0v1_index = new_vertex_indices[(f[0], f[1])]
        else:
            v0v1 = (verts[f[0]] + verts[f[1]])/2.
            v0v1 = v0v1 / np.linalg.norm(v0v1) * radius
            v0v1_index = len(output_verts)
            output_verts.append(v0v1)
            # add both edge permutations to dict
            new_vertex_indices[(f[0], f[1])] = v0v1_index
            new_vertex_indices[(f[1], f[0])] = v0v1_index
        
        if (f[1], f[2]) in new_vertex_indices:
            v1v2_index = new_vertex_indices[(f[1], f[2])]
        else:
            v1v2 = (verts[f[1]] + verts[f[2]])/2.
            v1v2 = v1v2 / np.linalg.norm(v1v2) * radius
            v1v2_index = len(output_verts)
            output_verts.append(v1v2)
            # add both edge permutations to dict
            new_vertex_indices[(f[1], f[2])] = v1v2_index
            new_vertex_indices[(f[2], f[1])] = v1v2_index

        if (f[2], f[0]) in new_vertex_indices:
            v2v0_index = new_vertex_indices[(f[2], f[0])]
        else:
            v2v0 = (verts[f[2]] + verts[f[0]])/2.
            v2v0 = v2v0 / np.linalg.norm(v2v0) * radius
            v2v0_index = len(output_verts)
            output_verts.append(v2v0)
            # add both edge permutations to dict
            new_vertex_indices[(f[2], f[0])] = v2v0_index
            new_vertex_indices[(f[0], f[2])] = v2v0_index

        #Add the four new faces to the output - index order matters so we don't flip the normal
        output_faces.append([f[0], v0v1_index, v2v0_index])
        output_faces.append([v0v1_index, f[1], v1v2_index])
        output_faces.append([v2v0_index, v1v2_index, f[2]])
        output_faces.append([v0v1_index, v1v2_index, v2v0_index])

    return output_verts, output_faces

def icosahedron_sphere_tessallation(radius=1., subdivisions=0):
    '''
    Returns the vertices and faces of a tessalated sphere, generated by subdividing an icosahedron
    radius - the radius of the sphere that is generated
    subdivisions - the number of times to subdivide the original icosahedron connectivity
    '''
    vertices = [np.array(v)/np.linalg.norm(v)*radius for v in icosahedron_verts]
    # the obj file wasn't zero indexed so subtract 1
    faces = [[i-1 for i in f] for f in icosahedron_faces]

    for i in range(subdivisions):
        vertices, faces = sphere_subdivision(vertices, faces, radius=radius)
    
    return vertices, faces

def load_object(obj_name, data_path):
    obj_file = os.path.join(data_path, f"{obj_name}.obj")

    obj_mesh = trimesh.load(obj_file)
    # obj_mesh.show()

    ## deepsdf normalization
    mesh_vertices = obj_mesh.vertices
    mesh_faces = obj_mesh.faces
    center = (mesh_vertices.max(axis=0) + mesh_vertices.min(axis=0))/2.0
    max_dist = np.linalg.norm(mesh_vertices - center, axis=1).max()
    max_dist = max_dist * 1.03
    mesh_vertices = (mesh_vertices - center) / max_dist
    obj_mesh = trimesh.Trimesh(vertices=mesh_vertices, faces=mesh_faces)
    
    return mesh_vertices, mesh_faces, obj_mesh

def make_point_cloud(points, colors=None):
    '''
    Returns an open3d point cloud given a list of points and optional colors
    '''
    point_cloud = o3d.geometry.PointCloud()
    point_cloud.points = o3d.utility.Vector3dVector(np.array(points))
    if colors is not None:
        point_cloud.colors = o3d.utility.Vector3dVector(np.array(colors))
    return point_cloud

def make_line_set(verts, lines, colors=None):
    '''
    Returns an open3d line set given vertices, line indices, and optional color
    '''
    line_set = o3d.geometry.LineSet()
    line_set.points = o3d.utility.Vector3dVector(verts)
    line_set.lines = o3d.utility.Vector2iVector(lines)
    if colors is not None:
        line_set.colors = o3d.utility.Vector3dVector(colors)
    return line_set


def show_histogram(values, lower, upper, resolution=0.5):
    values[values <= lower] = lower + 0.0001
    values[values >= upper] = upper - 0.0001
    plt.hist(values, bins = int((upper-lower)/resolution), range=(lower, upper), density=True)
    plt.show()



if __name__ == "__main__":

    v5_utils.seedRandom(42)
    nCores = 0#mp.cpu_count()
    Device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
    print(f"Using {Device}")

    Mask3D = IntersectionMask3DV2(dim=3, hidden_size=256)
    NeuralODF = ODFV5(input_size=6, radius=1.25, n_layers=7, pos_enc=False)



    output_dir = "F:\ivl-data\outputV5"
    odf_model = "mar15_3d_mask_v2"
    mask3d_model = "mar20th_mask3d_uniform_sampling_working"
    odf_checkpoint_dict = v5_utils.load_checkpoint(output_dir, odf_model, device=Device, load_best=True)
    mask_checkpoint_dict = v5_utils.load_checkpoint(output_dir, mask3d_model, device=Device, load_best=True)
    NeuralODF.load_state_dict(odf_checkpoint_dict['odf_model_state_dict'])
    Mask3D.load_state_dict(mask_checkpoint_dict['mask_model_state_dict'])
    NeuralODF = NeuralODF.to(Device)
    NeuralODF.eval()
    verts, faces, mesh = load_object("bunny_watertight", "F:\ivl-data\common-3d-test-models\data")
    lines = np.vstack([faces[:,:2], faces[:,1:], faces[:,(0,2)]])
    wf = make_line_set(verts, lines)


    # Get sphere surface vertices
    points, _ = icosahedron_sphere_tessallation(subdivisions=3)
    points = np.stack(points)
    view_dirs = points * -1.
    view_dirs = view_dirs / np.linalg.norm(view_dirs, axis=-1, keepdims=True)
    coordinates = np.concatenate([points, view_dirs], axis=1)
    coordinates = torch.tensor(coordinates, dtype=torch.float32).to(Device)

    # odf inference
    depths = NeuralODF([coordinates])[0]
    depths = depths.detach().cpu().numpy().flatten()
    depths = np.hstack([depths[:,None],]*3)
    surface_predictions = points + view_dirs*depths

    surface_predictions_torch = torch.unsqueeze(torch.tensor(surface_predictions, dtype=torch.float32), 2)
    occupancies = Mask3D([surface_predictions_torch])[0]
    occupancies = occupancies.detach().cpu().numpy().flatten()
    print(f"min: {np.min(occupancies)}")
    print(f"max: {np.max(occupancies)}")
    colors = [np.array([0., 0., 1.]) if abs(occupancies[i]) < 2. else np.array([1., 0., 0.]) for i in range(occupancies.shape[0])]
    occ_pc = make_point_cloud(surface_predictions, colors)
    o3d.visualization.draw_geometries([occ_pc, wf])


    show_histogram(occupancies, -5.0, 5.0)

    # 2nd round inference
    coordinates2 = torch.tensor(np.concatenate([surface_predictions, view_dirs], axis=1), dtype=torch.float32).to(Device)
    depths2 = NeuralODF([coordinates2])[0]
    depths2 = depths2.detach().cpu().numpy().flatten()
    depths2 = np.hstack([depths2[:,None],]*3)
    surface_predictions2 = surface_predictions + view_dirs*depths2

    pc = make_point_cloud(surface_predictions2)
    # o3d.visualization.draw_geometries([pc])

    # mask inference
    surface_predictions2 = torch.unsqueeze(torch.tensor(surface_predictions2, dtype=torch.float32), 2)
    occupancies = Mask3D([surface_predictions2])[0]
    occupancies = occupancies.detach().cpu().numpy().flatten()
    print(f"min: {np.min(occupancies)}")
    print(f"max: {np.max(occupancies)}")
    colors = [np.array([0., 0., 1.]) if abs(occupancies[i]) < 2. else np.array([1., 0., 0.]) for i in range(occupancies.shape[0])]
    occ_pc = make_point_cloud(surface_predictions2, colors)
    o3d.visualization.draw_geometries([occ_pc])


    show_histogram(occupancies, -5.0, 5.0)
